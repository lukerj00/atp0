# Milestone 1 — LeanWorker Verifier Service (Lean 4 + Mathlib pinned)

## Goal
Implement a **Dockerized Lean 4 verification microservice** (“LeanWorker”) that checks Lean proof candidates against a pinned Lean toolchain + pinned mathlib. This service is the proof oracle used by later orchestration (Plan → Prove → Refine).  

**Input:** theorem statement + proof block + imports (+ optional prelude/decls)  
**Output:** `ok/fail` + structured diagnostics + runtime metadata + echo of generated Lean file.

**No training. No LLM integration.** Pure verification.

---

## Scope (what to build)

### Deliverables
1. **LeanProject** pinned to:
   - a specific `lean-toolchain` version
   - a specific mathlib4 git commit
2. **LeanWorker HTTP server** (FastAPI recommended)
3. **POST /check** endpoint to verify a single theorem proof attempt
4. Structured parsing of Lean diagnostics into a stable JSON schema
5. **Dockerfile** building the environment and prebuilding dependencies (`lake build`)
6. Minimal **acceptance tests** (>=5 cases) + a simple local runner script
7. `GET /healthz` and `GET /version` endpoints

---

## Non-goals (Milestone 1)
- No interactive Lean editor protocol / REPL goal-state extraction (batch mode only)
- No optimization beyond `lake build` caching in the image
- No import minimization (default to `import Mathlib`)
- No multi-file theorem libraries (single file per check)
- No orchestration/search logic

---

## API Spec

### `GET /healthz`
**Response:**
```json
{ "ok": true }
GET /version
Return pinned build metadata.
Response example:

json
Copy code
{
  "toolchain": "leanprover/lean4:v4.14.0",
  "mathlib_commit": "<PINNED_COMMIT_HASH>",
  "build_time_utc": "2026-01-16T00:00:00Z"
}
POST /check
Verify a theorem proof attempt.

Request schema
json
Copy code
{
  "job_id": "optional-string",
  "imports": ["Mathlib"],
  "extra_prelude": "optional-string",
  "decls": "optional-string",
  "theorem_name": "T",
  "theorem_statement": "∀ n : Nat, n = n",
  "proof": "by\n  intro n\n  rfl",
  "options": {
    "timeout_ms": 15000
  }
}
Semantics / defaults
imports default: ["Mathlib"]

theorem_name default: "T" (sanitize to valid Lean identifier)

options.timeout_ms default: 15000

proof may either:

start with by (use as-is), OR

omit by (wrap inside := by ... and indent lines)

Response schema
json
Copy code
{
  "job_id": "string",
  "ok": true,
  "time_ms": 2314,
  "exit_code": 0,
  "lean_stdout": "string",
  "lean_stderr": "string",
  "diagnostics": [
    {
      "severity": "error|warning|info",
      "message": "string",
      "file": "Main.lean",
      "line": 12,
      "col": 5,
      "end_line": 12,
      "end_col": 20,
      "error_class": "type_mismatch|unknown_identifier|tactic_failed|unsolved_goals|timeout|parse_error|other",
      "raw": "string"
    }
  ],
  "artifact": {
    "lean_file": "string",
    "theorem_name": "string"
  }
}
Success criteria
ok=true iff Lean exits successfully (exit_code==0) and the file elaborates with no errors.

If Lean times out, set ok=false and include a timeout diagnostic:

error_class="timeout"

Lean file template (must be deterministic)
Generate Main.lean for each request:

lean
Copy code
-- AUTO-GENERATED by LeanWorker
-- job_id: <JOB_ID_OR_EMPTY>

import Mathlib
-- additional imports ...

set_option pp.all true
set_option pp.unicode.fun true
set_option maxRecDepth 2000

-- extra_prelude (verbatim)

-- decls (verbatim)

theorem <THEOREM_NAME> : <THEOREM_STATEMENT> := <PROOF_BLOCK>
Rules
Always include the header comment (traceability).

Imports first, then options, then extra_prelude, then decls, then theorem.

If proof does not start with by, wrap:

lean
Copy code
theorem T : <stmt> := by
  <proof-lines-indented>
Do not set maxHeartbeats 0 (rely on OS timeout).

Lean execution model (batch checking)
Command
Run from the pinned project root:

lake env lean Main.lean

Timeout
Use subprocess timeout; on timeout:

kill the process

return ok=false, exit_code=-1, diagnostics include timeout

Output capture
Capture:

stdout

stderr

exit code

runtime (ms)

Diagnostics parsing (V0 requirements)
Minimum viable parsing
Lean emits errors often like:

Main.lean:12:5: error: <message>

sometimes multi-line messages follow

Implement:

Split stderr into lines

Extract file/line/col + message when it matches:

^(.+\.lean):(\d+):(\d+): (error|warning|info): (.*)$

Store the remainder as raw (include multi-lines if easy, else just line)

Error classification (required)
Implement heuristic error_class mapping based on message substrings:

unknown_identifier if contains: unknown constant or unknown identifier

type_mismatch if contains: type mismatch or failed to synthesize

tactic_failed if contains: tactic and failed OR exact? failure patterns

unsolved_goals if contains: unsolved goals

parse_error if contains: unexpected token or parser error

timeout set explicitly when timeout triggers

else other

Note: This is intentionally heuristic and can be improved later. Stability matters more than completeness.

Project file structure (recommended)
markdown
Copy code
lean_worker/
  Dockerfile
  requirements.txt
  app/
    __init__.py
    server.py
    lean_runner.py
    template.py
    parse_diagnostics.py
    util.py
  LeanProject/
    lakefile.lean
    lean-toolchain
  benchmarks/
    cases.jsonl
    run_tests.py
Implementation overview (modules)
app/server.py
FastAPI app

endpoints: /healthz, /version, /check

request/response models with Pydantic

calls template → lean_runner → diagnostics parser

app/template.py
render_lean_file(req) -> str

sanitize theorem_name

import lines (dedupe)

wrap/indent proof if needed

app/lean_runner.py
run_lean_check(lean_file_text, timeout_ms) -> RunResult

create temp dir

write Main.lean

run lake env lean Main.lean in LEAN_PROJECT_ROOT

return stdout/stderr/exit_code/time_ms

app/parse_diagnostics.py
parse(stderr) -> list[Diagnostic]

classify(message) -> error_class

benchmarks/run_tests.py
calls local service or directly calls runner functions

includes at least 5 cases:

trivial success: ∀ n : Nat, n = n

simp success (pick a known lemma or by simp)

unknown identifier

tactic failed / unsolved goals

parse error

Dockerfile (required characteristics)
Requirements
Ubuntu 22.04 (or similar)

Install elan

Copy LeanProject, run:

lake update

lake build

Install Python deps

Start server on port 8080

Build-time notes
lake build may be slow; ensure Docker layer caching is used (copy LeanProject before app code so it caches the build when app changes).

Acceptance criteria (“Definition of Done”)
docker build -t leanworker . succeeds

docker run -p 8080:8080 leanworker starts the server

GET /healthz returns {ok:true}

POST /check:

returns ok=true for at least two valid proofs

returns ok=false and a meaningful error_class for:

unknown identifier

parse error

Output JSON is stable and matches the schema

Notes / Constraints for later milestones
Keep the API backward compatible (later orchestration will call /check at high volume).

Keep the Lean template stable (debugging/caching depends on stability).

Emit enough diagnostics detail to support repair loops in later milestones.

makefile
Copy code
::contentReference[oaicite:0]{index=0}